<script>

var radius = 250;

var projection = d3.geo.orthographic()
    .scale(radius)
    .translate([radius, radius])
    .clipAngle(90);

var svg = d3.select("body").append("svg")
    .attr("width", radius * 2)
    .attr("height", radius * 2)
    .on("mousedown", mousedown)
    .on("mousemove", mousemove)
    .on("mouseup", mouseup);

svg.append("circle")
    .attr("cx", radius)
    .attr("cy", radius)
    .attr("r", radius)
    .style("fill", "none")
    .style("stroke", "black");
    
var path = d3.geo.path()
    .projection(projection);

d3.json("world-countries.json", function(collection) {
  svg.selectAll("path")
      .data(collection.features)
    .enter().append("svg:path")
      .attr("d", path);
});

// 
function trackballAngles(pt) {
  // based on http://www.opengl.org/wiki/Trackball  
  // given a click at (x,y) in canvas coords on the globe (trackball),
  // calculate the spherical coordianates for the point as a rotation around
  // the vertical and horizontal axes
  
  var r = projection.scale();
  var c = projection.translate();
  var x = pt[0] - c[0], y = - (pt[1] - c[1]), ss = x*x + y*y;


  var z = r*r > 2 * ss ? Math.sqrt(r*r - ss) : r*r / 2 / Math.sqrt(ss);  

  var lambda = Math.atan2(x, z) * 180 / Math.PI; 
  var phi = Math.atan2(y, z) * 180 / Math.PI
  return [lambda, phi];
}

/*
This is the cartesian equivalent of the rotation matrix, 
which is the product of the following rotations (in numbered order):
1. longitude:  around the y axis (which points up in the canvas)
2. latitude: - around the x axis (which points right in the canvas)
3. yaw:        around the z axis (which points out of the screen)

NB.  If you measure rotations in a positive direction according to the right-hand rule 
(point your right thumb in the positive direction of the rotation axis, and rotate in the
direction of your curled fingers), then the latitude rotation is negative.

R(, , ) = 
[[ sin()sin()sin()+cos()cos(), sin()cos(), sin()sin()cos()+sin()cos()],
 [ sin()sin()cos()+sin()cos(), cos()cos(), sin()cos()cos()+sin()sin()],
 [ sin()cos(),                    sin(),       cos()cos()]]

If you then apply a "trackball rotation" of  around the y axis, and - around the 
x axis, you get this horrible composite matrix:

R2(, , , , ) = 
[[sin()sin()cos()+(sin()sin()sin()+cos()cos())cos(),
        sin()cos()cos()sin()sin(),
                sin()cos()cos()(sin()sin()cos()sin()cos())cos()],
 [sin()sin()cos()cos()(sin()sin()sin()+cos()cos())sin()sin()(sin()sin()cos()sin()cos())cos(),
        sin()sin()sin()cos()sin()sin()cos()+cos()cos()cos(),
                sin()cos()cos()cos()+(sin()sin()cos()sin()cos())sin()sin()+(sin()cos()cos()+sin()sin())cos()],
 [sin()cos()cos()cos()(sin()sin()sin()+cos()cos())sin()cos()+(sin()sin()cos()sin()cos())sin(),
        sin()sin()cos()cos()sin()cos()cos()sin()cos()cos(),
                cos()cos()cos()cos()+(sin()sin()cos()sin()cos())sin()cos()(sin()cos()cos()+sin()sin())sin()]]
                
by equating components of the matrics 
(label them [[a00, a01, a02], [a10, a11, a12], [a20, a21, a22]])
we can find an equivalent rotation R(', ', ') == RC(, , , , ) :
 
if cos(') != 0:
 ' = atan2(-RC01, RC11)
 ' = atan2(-RC21, ' == 0 ? RC11 / cos(') : - RC01 / sin('))
 ' = atan2(-RC20, RC22)
else:
 // when cos(') == 0, RC21 == - sin(') == +/- 1
 // the solution is degenerate, requiring just that
 //    ' - ' = atan2(RC00, RC10) if RC21 == -1 (' = /2)
 // or ' + ' = atan2(RC00, RC10) if RC21 == 1 (' = -/2)
 // so choose:
 ' = atan2(RC10, RC00) - RC21 * 
 ' = - RC21 * /2
 ' = 

*/

function composedRotation(, , , , ) {
     = Math.PI / 180 * ;
     = Math.PI / 180 * ;
     = Math.PI / 180 * ;
     = Math.PI / 180 * ;
     = Math.PI / 180 * ;
    
    var s = Math.sin(), s = Math.sin(), s = Math.sin(), 
        s = Math.sin(), s = Math.sin(),
        c = Math.cos(), c = Math.cos(), c = Math.cos(), 
        c = Math.cos(), c = Math.cos();

    var m00 = -s * s * c + (s * s * s + c * c) * c,
            m01 = -s * c * c - s * s,
                m02 = s * c * c - (s * s * c - s * c) * c,
        m10 = - s * s * c * c - (s * s * s + c * c) * s * s - (s * s * c - s * c) * c,
            m11 = s * s * s * c - s * s * c + c * c * c,
                 m12 = s * c * c * c + (s * s * c - s * c) * s * s + (s * c * c + s * s) * c,
        m20 = - s * c * c * c - (s * s * s + c * c) * s * c + (s * s * c - s * c) * s,
            m21 = s * s * c * c - s * c * c - s * c * c,
                 m22 = c * c * c * c + (s * s * c - s * c) * s * c - (s * c * c + s * s) * s;
                 
    if (m01 != 0 || m11 != 0) {
         _ = Math.atan2(-m01, m11);
         _ = Math.atan2(-m21, Math.sin(_) == 0 ? m11 / Math.cos(_) : - m01 / Math.sin(_));
         _ = Math.atan2(-m20, m22);
    } else {
         _ = Math.atan2(m10, m00) - m21 * ;
         _ = - m21 * Math.PI / 2;
         _ = ;       
    }
    
    return([_ * 180 / Math.PI, _ * 180 / Math.PI, _ * 180 / Math.PI]);
}
    
var m0 = null,
    o0;
  
function mousedown() {  // remember where the mouse was pressed, in canvas coords
  m0 = trackballAngles(d3.mouse(svg[0][0]));
  o0 = projection.rotate();
  d3.event.preventDefault();
}

function mousemove() {
  if (m0) {  // if mousedown
    var m1 = trackballAngles(d3.mouse(svg[0][0]));
    // we want to find rotate the current projection so that the point at m0 rotates to m1
    // along the great circle arc between them.
    // when the current projection is at rotation(0,0), with the north pole aligned
    // to the vertical canvas axis, and the equator aligned to the horizontal canvas
    // axis, this is easy to do, since D3's longitude rotation corresponds to trackball
    // rotation around the vertical axis, and then the subsequent latitude rotation 
    // corresponds to the trackball rotation around the horizontal axis.
    // But if the current projection is already rotated, it's harder.  
    // We need to find a new rotation equivalent to the composition of both
    
    // Choose one of these three update schemes:
    
    // Best behavior
    o1 = composedRotation(o0[0], o0[1], o0[2], m1[0] - m0[0], m1[1] - m0[1])
    
    // Improved behavior over original example
    //o1 = [o0[0] + (m1[0] - m0[0]), o0[1] + (m1[1] - m0[1])];
    
    // Original example from http://mbostock.github.io/d3/talk/20111018/azimuthal.html
    // o1 = [o0[0] - (m0[0] - m1[0]) / 8, o0[1] - (m1[1] - m0[1]) / 8];

    // move to the updated rotation
    projection.rotate(o1);
    
    // We can optionally update the "origin state" at each step.  This has the 
    // advantage that each 'trackball movement' is small, but the disadvantage of
    // potentially accumulating many small drifts (you often see a twist creeping in
    // if you keep rolling the globe around with the mouse button down)    
//    o0 = o1;
//    m0 = m1;

    svg.selectAll("path").attr("d", path); 
  }
}

function mouseup() {
  if (m0) {
    mousemove();
    m0 = null;
  }
}

</script>